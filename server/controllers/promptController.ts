import { RequestHandler } from 'express';
import { ServerError } from '../../types/types';
// import { fileURLToPath } from 'url';
// import fs from 'fs';
// import path from 'path';

type TopicKey = 'AI intelligence' | 'Free will';

type TopicLookupTable = {
  [K in TopicKey]: string;
};

export const parseArguments: RequestHandler = async (_req, res, next) => {
  const { userArguments, aiArguments } = res.locals;

  console.log('USER ARG: ', userArguments);
  console.log('AI ARG: ', aiArguments);

  const maxLen = Math.max(userArguments.length, aiArguments.length);

  let parsedArguments = '';

  //  parseArguments:
  //   Round 1 (AI): res.locals.ai_argument[0]
  //   Round 1 (user): res.locals.user_argument[0]
  //   Round 2 (AI): res.locals.ai_argument[1]
  //   Round 2 (user): res.locals.user_argument[1]
  //   ...

  for (let i = 0; i < maxLen; i++) {
    if (aiArguments[i]) {
      // Add to parsed Arguments
      parsedArguments += `Round ${i + 1} (AI): ${aiArguments[i]} \n\n`;
    }

    if (userArguments[i]) {
      parsedArguments += `Round ${i + 1} (User): ${userArguments[i]} \n\n`;
    }
  }

  res.locals.parsedArguments = parsedArguments;
  console.log('parsedArguments: ', parsedArguments);
  console.log('aguments parsed successfully');
  return next();
};

export const parseTopic: RequestHandler = async (_req, res, next) => {
  const { topic } = res.locals;

  const topicLookupTable: TopicLookupTable = {
    'AI intelligence': 'AI could eventually have true intelligence',
    'Free will': 'Do humans have free will?',
  };

  const roleLookupTable: TopicLookupTable = {
    'AI intelligence': 'philosopher of artificial intelligence',
    'Free will': 'professor of philosophy',
  };

  const parsedTopic =
    (topic as TopicKey) in topicLookupTable
      ? topicLookupTable[topic as TopicKey]
      : 'Unknown topic';

  const parsedRole =
    (topic as TopicKey) in roleLookupTable
      ? roleLookupTable[topic as TopicKey]
      : 'Unknown role';

  if (parsedTopic === 'Unknown topic' || parsedRole === 'Unknown role') {
    const error: ServerError = {
      log: 'unknown topic',
      status: 500,
      message: { err: 'cannot get a valid debate topic' },
    };

    return next(error);
  }
  res.locals.role = parsedRole;
  res.locals.parsedTopic = parsedTopic;
  console.log('parsedTopic: ', parsedTopic);
  console.log('topic parsed successfully');
  return next();
};

export const customizePrompts: RequestHandler = async (_req, res, next) => {
  const { parsedArguments, parsedTopic, userSide } = res.locals;
  const argumentString = parsedArguments
    ? parsedArguments
    : 'The initial argument is to be generated by AI.';

  const ai_side = userSide === 'pro' ? 'against' : 'for';

  const role = `You are a ${res.locals.role} in a back and forth dialogue with a user, where each person gets 3 rounds to make their argument total.`;
  const goal = `You are crafting a three-part argument ${ai_side} the idea that ${parsedTopic}. 
    `;
  const instructions = `
  You are currently in the round ${res.locals.round} of the debate with a human (user). You are representing the AI side.
  This is the existing debate between the user and AI so far: 
  ${argumentString}

  Please follow these instructions carefully: 
    - You will be sending one part of your argument at a time. 
    - For the first part of your argument, you will be crafting an initial argument about the topic and you will be expecting a rebuttal. 
    - After that, you will craft your next two parts of the argument by responding to particular elements of the user's rebuttal. 
    - You will be crafting each section of argument in response to the user's rebuttal of your previous claim. If user has made a claim or rebuttal, you should reponde with a direct and strong assertive counter argument. If user has a point that is particularly strong, you should acknowledge it and provide a counter argument. If user has a point that is particularly weak, you should point out the weakness, shame the user, and provide a super strong counter argument.
    - Be as conversational as possible in your argument - be personal and natural
    - You are acting as a person (a conversation partner). Do not be too formal and literal in your arguments. 
  `;

  const numOfPairs = 6;

  const responseFormat = `
  Your response will be passed to the frontend as a JSON object. Follow these instructions carefully: 
    - Do not include the word 'json' in your response. 
    - Your response should be a JSON object that contains ${numOfPairs} key-value pairs.
    - The first key should be "ai_argument" and have the value set as your counter argument.
    - The second key should be "ai_reasoning" and have the value set as your reason for providing this counter argument.
    - The third key should be "ai_strong_point" and have the value set as the perceived strengths of your counter argument.
    - The fourth key should be "ai_weak_point" and have the value set as a the perceived weaknesses of your counter argument.
    - The fifth key should be "user_strong_point" and have the value set as the perceived strengths in the user's latest argument.
    - The sixth key should be "user_weak_point" and have the value set as a the perceived weaknesses in the user's latest argument.
  `;
  // (if a user argument exists in the ${argumentString})
  const systemContent = role + goal + instructions + responseFormat;

  res.locals.systemContent = systemContent;
  console.log('systemContent: ', systemContent);
  console.log('prompts customized successfully');
  return next();
};

export const parseDebateHistoryFeedback: RequestHandler = async (
  _req,
  res,
  next
) => {
  const {
    userArguments,
    aiArguments,
    aiReasonings,
    aiStrongPoints,
    aiWeakPoints,
    userStrongPoints,
    userWeakPoints,
  } = res.locals;

  //  parsed history and feedback:
  //   Round 1 (AI's argument): res.locals.ai_argument[0]
  //   Round 1 (weak points in AI's argument): res.locals.ai_weak_point[0]
  //   Round 1 (strong points in AI's argument): res.locals.ai_strong_point[0]
  //   Round 1 (user's argument): res.locals.user_argument[0]
  //   Round 1 (weak points in user's argument): res.locals.user_weak_point[0]
  //   Round 1 (strong points in user's argument): res.locals.user_strong_point[0]
  //   Round 2 (AI's argument): res.locals.ai_argument[1]
  //   Round 2 (weak points in AI's argument): res.locals.ai_weak_point[1]
  //   Round 2 (strong points in AI's argument): res.locals.ai_strong_point[1]
  //   Round 2 (user's argument): res.locals.user_argument[1]
  //   Round 2 (weak points in user's argument): res.locals.user_weak_point[1]
  //   Round 2 (strong points in user's argument): res.locals.user_strong_point[1]
  //   Round 3 (AI's argument): res.locals.ai_argument[2]
  //   Round 3 (weak points in AI's argument): res.locals.ai_weak_point[2]
  //   Round 3 (strong points in AI's argument): res.locals.ai_strong_point[2]
  //   Round 3 (user's argument): res.locals.user_argument[2]
  //   Round 3 (weak points in user's argument): res.locals.user_weak_point[2]
  //   Round 3 (strong points in user's argument): res.locals.user_strong_point[2]
  //

  // FIRST AI RESPONSE:[ ai response 1] +[ ai weak points 1] + [ai strong points 1]
  // FIRST USER RESPONSE: [user response 1] + [ ai response 1] +[ ai weak points 1] + [ai strong points 1]
  // SECOND AI RESPONSE: [user response 1] + [ ai response 1, aiReponse 2] +[ ai weak points 1, 2] + [ai strong points 1, 3], [user weak points 1] + [user strong points 2]
  // SECOND USER RESPONSE: [user response 1, 2] + [ ai response 1, aiReponse 2] +[ ai weak points 1, 2] + [ai strong points 1, 3], [user weak points 1] + [user strong points 2]
  // THIRD AI RESPONSE: [user response 1, 2] + [ ai response 1, aiReponse 2, 3] +[ ai weak points 1, 2, 3] + [ai strong points 1, 2, 3], [user weak points 1, 2] + [user strong points 1, 2]
  // THIRD USER RESPONSE: [user response 1, 2, 3] + [ ai response 1, aiReponse 2] +[ ai weak points 1, 2] + [ai strong points 1, 3], [user weak points 1] + [user strong points 2]
  // FOURTH AI RESPONSE: [user response 1, 2, 3] + [ ai response 1, aiReponse 2, 3, 4] +[ ai weak points 1, 2, 3, 4] + [ai strong points 1, 2, 3, 4], [user weak points 1, 2, 3] + [user strong points 1, 2, 3]

  const maxLen = Math.max(userArguments.length, aiArguments.length);

  let debateHistoryFeedback = '';

  for (let i = 0; i < maxLen - 1; i++) {
    if (aiArguments[i]) {
      // Add to parsed Arguments
      debateHistoryFeedback += `Round ${i + 1} (AI's argument): ${aiArguments[i]} \n`;
      debateHistoryFeedback += `Round ${i + 1} (weak points in AI's argument): ${aiWeakPoints[i]} \n`;
      debateHistoryFeedback += `Round ${i + 1} (strong points in AI's argument): ${aiStrongPoints[i]} \n`;
    }

    if (userArguments[i]) {
      debateHistoryFeedback += `Round ${i + 1} (User's Argument): ${userArguments[i]} \n`;
      debateHistoryFeedback += `Round ${i + 1} (weak points in user's argument): ${userWeakPoints[i + 1]} \n`;
      debateHistoryFeedback += `Round ${i + 1} (weak points in user's argument): ${userStrongPoints[i + 1]} \n`;
    }
  }

  res.locals.debateHistoryFeedback = debateHistoryFeedback;
  console.log('debateHistoryFeedback: ', debateHistoryFeedback);
  console.log('debate history parsed successfully');
};

export const customizeEvaluationPrompts: RequestHandler = async (_req, res, next) => {

  const { debateHistoryFeedback, topic, userSide } = res.locals;

  const role = '';

  const systemEvaluationContent = role;

  res.locals.systemEvaluationContent = systemEvaluationContent;

  return next();
}



